package com.example.jpa.service;

import com.example.jpa.dto.TransactionRequestDTO;
import com.example.jpa.dto.UserDTO;
import com.example.jpa.error.exceptions.AccountException;
import com.example.jpa.repository.AccountRepository;
import com.example.jpa.repository.UserRepository;
import com.example.jpa.dto.AccountRequestDTO;
import com.example.jpa.dto.RoleDTO;
import com.example.jpa.mapper.*;
import com.example.jpa.matcher.AccountMatcher;
import com.example.jpa.model.IcesiAccount;
import com.example.jpa.model.IcesiRole;
import com.example.jpa.model.IcesiUser;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class AccountServiceTest {

    private AccountService accountService;
    private AccountRepository accountRepository;
    private AccountMapper mapper;
    private UserRepository userRepository;

    private final String NORMAL = "NORMAL";
    private final String DEPOSIT = "DEPOSIT";

    @BeforeEach
    private void init(){
        accountRepository = mock(AccountRepository.class);
        mapper = spy(AccountMapperImpl.class);
        userRepository = mock(UserRepository.class);
        accountService = new AccountService(accountRepository,mapper,userRepository);
    }

    @Test
    public void testSaveAccount(){
        when(userRepository.findByEmail(any())).thenReturn(Optional.ofNullable(defaultUser()));
        accountService.save(defaultAccountDTO());
        verify(userRepository,times(1)).findByEmail(any());
        verify(mapper,times(1)).fromAccountDTO(any());
        verify(accountRepository,times(1)).save(argThat(new AccountMatcher(defaultAccount(NORMAL))));
    }

    @Test
    public void testSaveAccountWhenTheBalanceIsBellowZero() {
        AccountRequestDTO account = defaultAccountDTO();
        account.setBalance(-1L);
        when(userRepository.findByEmail(any())).thenReturn(Optional.ofNullable(defaultUser()));
        try {
            accountService.save(account);
            fail();
        }catch (Exception e){
            assertEquals("Low balance: " + account.getBalance()
                    + "/n" + "Balance can't be negative",e.getMessage());
        }
    }
    // This test validate that the account number generated by the service always is unique, therefore it does not fail.
    @Test
    public void testSaveAccountWhenTheNumberAlreadyExists(){
        when(userRepository.findByEmail(any())).thenReturn(Optional.ofNullable(defaultUser()));
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.ofNullable(defaultAccount(NORMAL)));
        accountService.save(defaultAccountDTO());
        verify(userRepository,times(1)).findByEmail(any());
        verify(mapper,times(1)).fromAccountDTO(any());
        verify(accountRepository,times(1)).save(argThat(new AccountMatcher(defaultAccount(NORMAL))));
    }

    @Test
    public void testSaveAccountWhenTheUserDoesNotExist(){
        when(userRepository.findByEmail(any())).thenReturn(Optional.empty());
        try {
            accountService.save(defaultAccountDTO());
            fail();
        }catch (Exception e){
            assertEquals("User not found",e.getMessage());
        }
    }

    @Test
    public void testDisableAccount(){
        IcesiAccount account = defaultAccount(NORMAL);
        account.setBalance(0L);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.of(account));
        assertTrue(accountService.disableAccount(anyString()));
        verify(accountRepository, times(1)).save(argThat(new AccountMatcher(account)));
    }

    @Test
    public void testDisableAccountWhenBalanceIsNotZero(){
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.ofNullable(defaultAccount(NORMAL)));
        try {
            accountService.disableAccount(defaultAccount(NORMAL).getAccountNumber());
            fail();
        }catch (Exception e){
            assertEquals("The account has a positive balance, it's not recommended to disable it",e.getMessage());
        }
    }

    @Test
    public void testDisableAccountWhenTheAccountDoesNotExist(){
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.empty());
        try {
            accountService.disableAccount(defaultAccount(NORMAL).getAccountNumber());
            fail();
        }catch (Exception e){
            assertEquals("Account " + defaultAccount(NORMAL).getAccountNumber() + " not found",e.getMessage());
        }
    }

    @Test
    public void testEnableAccount(){
        IcesiAccount account = defaultAccount(NORMAL);
        account.setActive(false);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.of(account));
        assertTrue(accountService.enableAccount(anyString()));
        verify(accountRepository,times(1)).save(argThat(new AccountMatcher(account)));
    }

    @Test
    public void testEnableAccountWhenTheAccountNotExist(){
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.empty());
        try {
            accountService.enableAccount(defaultAccount(NORMAL).getAccountNumber());
            fail();
        }catch (Exception e){
            assertEquals("Account " + defaultAccount(NORMAL).getAccountNumber() + " not found",e.getMessage());
        }
    }

    @Test
    public void testEnableAccountWhenTheBalanceIsNegative(){
        IcesiAccount account = defaultAccount(NORMAL);
        account.setActive(false);
        account.setBalance(-1L);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.of(account));
        try {
            accountService.enableAccount(account.getAccountNumber());
            fail();
        }catch (Exception e){
            assertEquals("Low balance: " + account.getBalance()
                    + "/n" + "Balance can't be negative",e.getMessage());
        }
    }

    @Test
    public void testWithdraw(){
        IcesiAccount icesiAccount = defaultAccount(NORMAL);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.ofNullable(icesiAccount));
        accountService.withdraw(defaultWithdrawTransaction(5L));
        assertEquals(5L,icesiAccount.getBalance());
        verify(accountRepository, times(1)).getByAccountNumber(any());
        verify(accountRepository,times(1)).save(argThat(new AccountMatcher(icesiAccount)));
    }

    //Default withdraw transaction DTO
    private TransactionRequestDTO defaultWithdrawTransaction(Long amount){
        return TransactionRequestDTO.builder()
                .sourceAccount(defaultAccount(NORMAL).getAccountNumber())
                .amount(amount)
                .build();
    }

    @Test
    public void testWithdrawWhenTheBalanceIsLess(){
        IcesiAccount icesiAccount = defaultAccount(NORMAL);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.ofNullable(icesiAccount));
        try{
            accountService.withdraw(defaultWithdrawTransaction(15L));
            fail();
        }catch (Exception e){
            assertEquals("Low balance: " + icesiAccount.getBalance()
                    + "/n" + "Balance can't be negative",e.getMessage());
        }
        assertEquals(10L,icesiAccount.getBalance());
        verify(accountRepository, times(1)).getByAccountNumber(any());
    }

    @Test
    public void testWithdrawWhenTheAmountIsNegative(){
        IcesiAccount icesiAccount = defaultAccount(NORMAL);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.ofNullable(icesiAccount));
        try{
            accountService.withdraw(defaultWithdrawTransaction(-5L));
            fail();
        }catch (Exception e){
            assertEquals("Amount can't be negative",e.getMessage());
        }
        assertEquals(10L,icesiAccount.getBalance());
        verify(accountRepository, times(1)).getByAccountNumber(any());
    }

    @Test
    public void testWithdrawWhenTheAccountDoesNotExist(){
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.empty());
        try{
            accountService.withdraw(defaultWithdrawTransaction(15L));
            fail();
        }catch (Exception e){
            assertEquals("Account " + defaultWithdrawTransaction(15L).getSourceAccount() + " not found",e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
        verify(accountRepository,times(1)).getByAccountNumber(any());
    }

    @Test
    public void testDeposit(){
        IcesiAccount icesiAccount = defaultAccount(NORMAL);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.ofNullable(icesiAccount));
        accountService.deposit(defaultDepositTransaction(5L));
        assertEquals(15L,icesiAccount.getBalance());
        verify(accountRepository, times(1)).getByAccountNumber(any());
        verify(accountRepository,times(1)).save(argThat(new AccountMatcher(icesiAccount)));
    }

    private TransactionRequestDTO defaultDepositTransaction(Long amount){
        return TransactionRequestDTO.builder()
                .targetAccount(defaultAccount(NORMAL).getAccountNumber())
                .amount(amount)
                .build();
    }

    @Test
    public void testDepositWhenTheAmountIsNegative(){
        IcesiAccount icesiAccount = defaultAccount(NORMAL);
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.ofNullable(icesiAccount));
        try{
            accountService.deposit(defaultDepositTransaction(-5L));
            fail();
        }catch (Exception e){
            assertEquals("Amount can't be negative",e.getMessage());
        }
        assertEquals(10L,icesiAccount.getBalance());
        verify(accountRepository, times(1)).getByAccountNumber(any());
    }

    @Test
    public void depositWhenTheAccountDoesNotExist(){
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.empty());
        try{
            accountService.deposit(defaultDepositTransaction(15L));
            fail();
        }catch (Exception e){
            assertEquals("Account " + defaultDepositTransaction(15L).getTargetAccount() + " not found",e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
        verify(accountRepository,times(1)).getByAccountNumber(any());
    }


    @Test
    public void testTransfer(){
        IcesiAccount sourceAccount = defaultAccount(NORMAL);
        IcesiAccount targetAccount = defaultAccount(NORMAL);
        targetAccount.setAccountNumber("233-121219-21");

        when(accountRepository.getByAccountNumber("897-887868-67")).thenReturn(Optional.ofNullable(sourceAccount));
        when(accountRepository.getByAccountNumber("233-121219-21")).thenReturn(Optional.ofNullable(targetAccount));

        accountService.transfer(defaultTransferTransaction(sourceAccount.getAccountNumber(),targetAccount.getAccountNumber(),5L));

        verify(accountRepository,times(2)).save(any(IcesiAccount.class));
        verify(accountRepository,times(2)).getByAccountNumber(any());
        assertEquals(5L,sourceAccount.getBalance());
        assertEquals(15L,targetAccount.getBalance());
    }

    private TransactionRequestDTO defaultTransferTransaction(String sourceAccount, String targetAccount, Long amount){
        return TransactionRequestDTO.builder()
                .sourceAccount(sourceAccount)
                .targetAccount(targetAccount)
                .amount(amount)
                .build();
    }

    @Test
    public void testTransferWhenBothAccountsDoNotExist(){
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.empty());
        when(accountRepository.getByAccountNumber(any())).thenReturn(Optional.empty());
        try{
            accountService.transfer(defaultTransferTransaction("897-887868-67","233-121219-21",5L));
            fail();
        }catch (Exception e){
            assertEquals("Account 897-887868-67 not found",e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
        assertThrows(AccountException.class, () -> accountService.transfer(defaultTransferTransaction("897-887868-67","233-121219-21",5L)));
    }



    @Test
    public void testTransferWhenAnAccountDoesNotExist(){
        when(accountRepository.getByAccountNumber("897-887868-67")).thenReturn(Optional.ofNullable(defaultAccount(NORMAL)));
        when(accountRepository.getByAccountNumber("233-121219-21")).thenReturn(Optional.empty());
        try{
            accountService.transfer(defaultTransferTransaction("897-887868-67","233-121219-21",5L));
            fail();
        }catch (Exception e) {
            assertEquals("Account 233-121219-21 not found", e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
    }

    @Test
    public void testTransferWhenAnAccountIsDeposit(){
        IcesiAccount depositTestAccount = defaultAccount(DEPOSIT);
        depositTestAccount.setAccountNumber("233-121219-21");

        when(accountRepository.getByAccountNumber("233-121219-21")).thenReturn(Optional.of(depositTestAccount));
        when(accountRepository.getByAccountNumber("897-887868-67")).thenReturn(Optional.ofNullable(defaultAccount(NORMAL)));

        try {
            accountService.transfer(defaultTransferTransaction("233-121219-21","897-887868-67",5L));
            fail();
        }catch (Exception e){
            assertEquals("One or both accounts are of type deposit",e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
        assertEquals(10L,depositTestAccount.getBalance());
    }


    @Test
    public void testTransferWhenBothAccountsAreDeposit(){
        IcesiAccount sourceAccount = defaultAccount(DEPOSIT);
        sourceAccount.setAccountNumber("233-121219-21");
        IcesiAccount targetAccount = defaultAccount(DEPOSIT);

        when(accountRepository.getByAccountNumber("233-121219-21")).thenReturn(Optional.ofNullable(sourceAccount));
        when(accountRepository.getByAccountNumber("897-887868-67")).thenReturn(Optional.ofNullable(targetAccount));

        try {
            accountService.transfer(defaultTransferTransaction("233-121219-21","897-887868-67",5L));
            fail();
        }catch (Exception e){
            assertEquals("One or both accounts are of type deposit" ,e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
        verify(accountRepository,times(2)).getByAccountNumber(any());
        assertEquals(10L,sourceAccount.getBalance());
        assertEquals(10L,targetAccount.getBalance());
    }

    @Test
    public void testTransferWithAnInactiveAccount(){
        IcesiAccount account = defaultAccount(NORMAL);
        account.setActive(false);
        account.setAccountNumber("233-121219-21");
        when(accountRepository.getByAccountNumber("233-121219-21")).thenReturn(Optional.ofNullable(account));
        when(accountRepository.getByAccountNumber("897-887868-67")).thenReturn(Optional.ofNullable(defaultAccount(NORMAL)));
        try {
            accountService.transfer(defaultTransferTransaction("233-121219-21","897-887868-67",5L));
            fail();
        }catch (Exception e){
            assertEquals("One or both accounts are not active",e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
        verify(accountRepository,times(2)).getByAccountNumber(any());
        assertEquals(10L,account.getBalance());
    }

    @Test
    public void testTransferWhenSourceAccountHasInsufficientFunds(){
        IcesiAccount sourceAccount = defaultAccount(NORMAL);
        sourceAccount.setAccountNumber("233-121219-21");
        when(accountRepository.getByAccountNumber("233-121219-21")).thenReturn(Optional.ofNullable(sourceAccount));
        when(accountRepository.getByAccountNumber("897-887868-67")).thenReturn(Optional.ofNullable(defaultAccount(NORMAL)));
        try {
            accountService.transfer(defaultTransferTransaction("233-121219-21","897-887868-67",15L));
            fail();
        }catch (Exception e){
            assertEquals("Low balance: " + sourceAccount.getBalance() +
                    "/n" + "Balance can't be negative",e.getMessage());
        }
        verify(accountRepository,times(0)).save(any());
        verify(accountRepository,times(2)).getByAccountNumber(any());
        assertEquals(10L,sourceAccount.getBalance());
    }

    private IcesiAccount defaultAccount(String type){
        return IcesiAccount.builder()
                .accountNumber("897-887868-67")
                .balance(10L)
                .active(true)
                .type(type)
                .user(defaultUser())
                .build();
    }

    private AccountRequestDTO defaultAccountDTO(){
        return AccountRequestDTO.builder()
                .balance(10L)
                .type(NORMAL)
                .user(defaultUserDTO())
                .build();
    }


    private IcesiUser defaultUser(){
        return IcesiUser.builder()
                .userId(UUID.fromString("6ee86844-1e1e-41d1-b7e7-72471a144645"))
                .firstName("Jhon")
                .lastName("Doe")
                .phoneNumber("672155121")
                .password("123456789")
                .email("jhon.doe@gmail.com")
                .role(defaultRole())
                .icesiAccountList(new ArrayList<>())
                .build();
    }

    private UserDTO defaultUserDTO(){
        return UserDTO.builder()
                .firstName("Jhon")
                .lastName("Doe")
                .phoneNumber("672155121")
                .password("123456789")
                .email("jhon.doe@gmail.com")
                .role(defaultRoleDTO())
                .build();
    }

    private IcesiRole defaultRole(){
        return IcesiRole.builder()
                .name("FirstRole")
                .description("This is a test for the role")
                .icesiUserList(new ArrayList<>())
                .build();
    }

    private RoleDTO defaultRoleDTO(){
        return   RoleDTO.builder()
                .name("FirstRole")
                .description("This is a test for the role")
                .build();
    }

}
